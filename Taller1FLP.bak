#lang eopl

;; Integrantes:
;; Juan Esteban Arias Saldaña (2417915)
;; Valeria Zamudio Arevalo (2415210)

;;1
;; invert :
;; Proposito:
;; L x P -> L’: Recibe una lista L y un predicado P.
;; Devuelve una lista con las sublistas de L cuyos dos primeros
;; elementos cumplen el predicado P, pero invertidos.
;; <invertir> := ()
;;         := ((<valor-de-scheme> <valor-de-scheme>) <invertir>)

;; aplicarPredicado :
;; Proposito:
;; L x P -> L’: Recibe una sublista L y un predicado P.
;; Si los dos primeros elementos de L cumplen P,
;; devuelve una lista con esos dos elementos invertidos.
;; En caso contrario devuelve la lista vacia.
;;
;; <aplicar> := ()
;;           := (<valor-de-scheme> <valor-de-scheme>)

(define invert (lambda (L P)
                 (letrec (
                          (aplicarPredicado (lambda (L P)
                                             (if
                                              (and (P (car L)) (P (cadr L))) (cons (cadr L) (cons (car L) '()))
                                              '()
                                              ))))
                   (cond
                     [(null? L) '()]
                     [(null? (aplicarPredicado (car L) P)) (invert (cdr L) P)]
                     [else (cons (aplicarPredicado (car L) P) (invert (cdr L) P))]
                     ))))

;; Pruebas invert
(invert '((3 2) (4 2) (1 5) (2 8)) even?)
(invert '((6 9) (10 90) (82 7)) odd?)
(invert '((2 4) (6 8)) number?)

;; Pruebas aplicarPredicado
;;(aplicarPredicado '(4 6) even?)
;;(aplicarPredicado '(3 5) even?)
;;(aplicarPredicado '(7 9) odd?)


;;2
;; down :
;; Proposito:
;; L -> L’: Transforma cada elemento de la lista L en una lista unitaria.
;;
;; <lista> := ()
;;         := ((<valor-de-scheme>) <lista>)

(define down (lambda (L) 
                        (if
                          (null? L) '()
                          (cons (cons (car L) '()) (down (cdr L)))
                         )))

;; Pruebas down
(down '(1 2 3))
(down '((a) (b) (c)))
(down '(x (y z) w))


;;3
;; list-set :
;; Proposito:
;; L x n x x x P -> L’: Reemplaza el
;; elemento en la posicion n de la lista L por el valor x,
;; solo si dicho elemento cumple el predicado P.
;;
;; <lista> := ()
;;         := (<valor-de-scheme> <lista>)

;; acumulador :
;; Proposito:
;; L x n x x x P x acum -> L’: Recorre la lista con un contador (acum).
;; Cuando el contador coincide con n,
;; reemplaza el elemento por x si este elemento cumple P.
;; En caso contrario, continua el recorrido sin modificar.
;;
;; <acumular> := ()
;;            := (<valor-de-scheme> <acumular>)

(define list-set (lambda (L n x P)
                   (letrec (
                            (acumulador (lambda (L n x P acum)
                                          (if
                                           (eq? acum n)
                                           (if (P (car L))
                                               (cons x (cdr L))
                                               L)
                                           (cons (car L) (acumulador (cdr L) n x P (+ 1 acum)))
                                           ))))
                     (cond
                       [(null? L) '()]
                       [else (acumulador L n x P 0)]
                       ))))

;; Pruebas list-set
(list-set '(5 8 7 6) 2 '(1 2) odd?)
(list-set '(5 8 7 6) 2 '(1 2) even?)
(list-set '(2 4 6 8) 1 'a even?)

;; Pruebas acumulador
;;(acumulador '(5 8 7 6) 2 '(1 2) odd? 0)
;;(acumulador '(2 4 6 8) 1 'a even? 0)


;;4
;; filter-in :
;; Proposito:
;; P x L -> L’: Devuelve una nueva lista con los elementos de L que cumplen el predicado P.
;;
;; <filtrar> := ()
;;           := (<valor-de-scheme> <filtrar>)

(define filter-in (lambda (P L)
                                (cond
                                 [(null? L) '()]
                                 [(P (car L)) (cons (car L) (filter-in P (cdr L)))]
                                 [else (filter-in P (cdr L))]
                                 )))

;; Pruebas filter-in
(filter-in number? '(a 2 (1 3) b 7))
(filter-in symbol? '(a (b c) 17 d))
(filter-in even? '(1 2 3 4 5 6))


;;5
;; palindrome? :
;; Proposito:
;; palabra -> boolean: Determina si una palabra (lista) es un palindromo.
;;
;; <palindrome> := #t | #f

;; invertirPalabra :
;; Proposito:
;; L x acum -> L’: Invierte recursivamente la lista L usando un acumulador para construir la lista invertida.
;;
;; <invertir> := ()
;;            := (<valor-de-scheme> <invertir>)

(define palindrome? (lambda (palabra)
                      (letrec (
                               (invertirPalabra (lambda (L acum)
                                 (if
                                  (null? L) acum
                                  (invertirPalabra (cdr L) (cons (car L) acum))
                                  ))))
                        (if
                         (null? palabra) #t
                         (equal? palabra (invertirPalabra palabra '()))
                         ))))

;; Pruebas palindrome?
(palindrome? '(r a p a r))
(palindrome? '(s a n a s))
(palindrome? '(c a m b i o))

;; Pruebas invertirPalabra
;;(invertirPalabra '(1 2 3) '())
;;(invertirPalabra '(a b c d) '())


;;6
;; swapper :
;; Proposito:
;; E1 x E2 x L -> L’: Intercambia todas las ocurrencias
;; de E1 por E2 y de E2 por E1 dentro de la lista L.
;;
;; <swap> := ()
;;        := (<valor-de-scheme> <swap>)

(define swapper (lambda (E1 E2 L)
                                (cond
                                 [(null? L) '()]
                                 [(eq? (car L) E1) (cons E2 (swapper E1 E2 (cdr L)))]
                                 [(eq? (car L) E2) (cons E1 (swapper E1 E2 (cdr L)))]
                                 [else (cons (car L) (swapper E1 E2 (cdr L)))]
                                 )))

;; Pruebas swapper
(swapper 'a 'd '(a b c d))
(swapper 'x 'y '(y y x y x))
(swapper 1 2 '(1 2 3 2 1))


;;7
;; unirListas :
;; Proposito:
;; L1 x L2 -> L’: Une dos listas en una sola.
;;
;; <listas> := ()
;           := (<valor-de-scheme> <listas>)

(define unirListas (lambda (L1 L2)
  (if (null? L1) L2
      (cons (car L1) (unirListas (cdr L1) L2)))))

;; Pruebas unirListas
(unirListas '(1 2 3) '(4 5))
(unirListas '() '(a b))
(unirListas '(x y) '())


;; cartesian-product :
;; Proposito:
;; L1 x L2 -> L’: Devuelve el producto cartesiano
;; entre las listas L1 y L2.
;;
;; <cartesiano> := ()
;;              := ((<valor-de-scheme> <valor-de-scheme>) <cartesiano>) 


;; combinacion :
;; Proposito:
;; L1 x L2 -> L’: Genera las combinaciones entre el primer
;; elemento de L1 y todos los elementos de L2.
;;
;; <par> := ()
;;       := ((<valor-de-scheme> <valor-de-scheme>) <par>)

(define cartesian-product (lambda (L1 L2)
                      (letrec (
                               (combinacion (lambda (L1 L2)
                                 (cond
                                  [(null? L1) '()]
                                  [(null? L2) '()]
                                  [else (cons (list (car L1) (car L2)) (combinacion L1 (cdr L2)))]
                                  ))))
                        (cond
                         [(null? L1) '()]
                         [(null? L2) '()]
                         [else (unirListas (combinacion L1 L2) (cartesian-product (cdr L1) L2))]
                         ))))

;; Pruebas cartesian-product
(cartesian-product '(a b c) '(x y))
(cartesian-product '(1 2) '(3 4))
(cartesian-product '() '(a b))

;; Pruebas combinacion
;;(combinacion '(a) '(x y))
;;(combinacion '(1) '(2 3 4))


;;16
;; hanoi :
;; Proposito:
;; n x origen x auxiliar x destino -> L : Devuelve la lista de movimientos necesarios
;; para trasladar n discos de la torre origen a la torre destino.
;; Cada movimiento se representa como (origen destino).
;;
;;<movimientos> := ()
;;              := (<movimiento> <movimientos>)
;;
;;<movimiento> := (<simbolo> <simbolo>)

(define hanoi (lambda (n origen auxiliar destino)
                (cond
                  [(= n 0) '()]
                  [(= n 1) (cons (list origen destino) '())]
                  [else (unirListas (hanoi (- n 1) origen destino auxiliar)
                                    (unirListas (list (list origen destino))
                                                (hanoi (- n 1) auxiliar origen destino)))]
                  )))

;; Pruebas hanoi
(hanoi 1 'A 'B 'C)
(hanoi 2 'A 'B 'C)
(hanoi 3 'A 'B 'C)


;;17
;; coin-change :
;; Proposito:
;; monto x monedas -> numero: Devuelve la cantidad de formas distintas
;; de formar el monto usando las monedas dadas.
;; Usa recursión considerando tomar la moneda actual o ignorarla y pasar a la siguiente
;;
;; <cambio> := ()
;;          := (<valor-de-scheme> <cambio>)

(define coin-change (lambda (monto monedas)
                                          (cond
                                            [(= monto 0) 1]
                                            [(< monto 0) 0]
                                            [(null? monedas) 0]
                                            [else (+ (coin-change (- monto (car monedas)) monedas) (coin-change monto (cdr monedas)))]
                                            )))

;; Pruebas coin-change
(coin-change 5 '(1 5))
(coin-change 5 '(1 2 5))
(coin-change 10 '(2 5 3 6))



